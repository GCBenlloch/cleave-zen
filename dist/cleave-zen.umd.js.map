{"version":3,"file":"cleave-zen.umd.js","sources":["../src/common/utils.ts","../src/credit-card/constants.ts","../src/numeral/constants.ts","../src/credit-card/index.ts","../src/date/constants.ts","../src/date/index.ts","../src/time/constants.ts","../src/time/index.ts","../src/general/index.ts","../src/numeral/index.ts","../src/cursor-tracker/index.ts"],"sourcesContent":["import type {\r\n  StripDelimitersProps,\r\n  GetFormattedValueProps,\r\n  BlocksType,\r\n  DelimiterType,\r\n} from './types'\r\n\r\n// const test = (): string => {\r\n//   return 'test-eslint'\r\n// }\r\n\r\nexport const isString = (value: any): value is string =>\r\n  typeof value === 'string'\r\n\r\nexport const stripNonNumeric = (value: string): string =>\r\n  value.replace(/[^\\d]/g, '')\r\n\r\nexport const getMaxLength = (blocks: BlocksType): number =>\r\n  blocks.reduce((previous: number, current: number) => previous + current, 0)\r\n\r\nexport const headStr = (str: string, length: number): string =>\r\n  str.slice(0, length)\r\n\r\nexport const getDelimiterRegexByDelimiter = (delimiter: string): RegExp =>\r\n  new RegExp(delimiter.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1'), 'g')\r\n\r\nexport const stripDelimiters = ({\r\n  value,\r\n  delimiters,\r\n}: StripDelimitersProps): string => {\r\n  delimiters.forEach((current: DelimiterType) => {\r\n    current.split('').forEach(letter => {\r\n      value = value.replace(getDelimiterRegexByDelimiter(letter), '')\r\n    })\r\n  })\r\n\r\n  return value\r\n}\r\n\r\nexport const getFormattedValue = ({\r\n  value,\r\n  blocks,\r\n  delimiter = '',\r\n  delimiters = [],\r\n  delimiterLazyShow = false,\r\n}: GetFormattedValueProps): string => {\r\n  let result = ''\r\n  let valueRemaining = value\r\n  let currentDelimiter = ''\r\n\r\n  blocks.forEach((length: number, index: number) => {\r\n    if (valueRemaining.length > 0) {\r\n      const sub = valueRemaining.slice(0, length)\r\n      const rest = valueRemaining.slice(length)\r\n\r\n      if (delimiters.length > 0) {\r\n        currentDelimiter =\r\n          delimiters[delimiterLazyShow ? index - 1 : index] ?? currentDelimiter\r\n      } else {\r\n        currentDelimiter = delimiter\r\n      }\r\n\r\n      if (delimiterLazyShow) {\r\n        if (index > 0) {\r\n          result += currentDelimiter\r\n        }\r\n\r\n        result += sub\r\n      } else {\r\n        result += sub\r\n\r\n        if (sub.length === length && index < blocks.length - 1) {\r\n          result += currentDelimiter\r\n        }\r\n      }\r\n\r\n      // update remaining string\r\n      valueRemaining = rest\r\n    }\r\n  })\r\n\r\n  return result\r\n}\r\n","import type { DelimiterType } from '../common/types'\r\nimport type { CreditCardBlocksType, CreditCardRegexType } from './types'\r\n\r\nexport const DefaultCreditCardDelimiter: DelimiterType = ' '\r\n\r\nexport enum CreditCardType {\r\n  UATP = 'uatp',\r\n  AMEX = 'amex',\r\n  DINERS = 'diners',\r\n  DISCOVER = 'discover',\r\n  MASTERCARD = 'mastercard',\r\n  DANKORT = 'dankort',\r\n  INSTAPAYMENT = 'instapayment',\r\n  JCB15 = 'jcb15',\r\n  JCB = 'jcb',\r\n  MAESTRO = 'maestro',\r\n  VISA = 'visa',\r\n  MIR = 'mir',\r\n  UNIONPAY = 'unionpay',\r\n  GENERAL = 'general',\r\n}\r\n\r\nexport const CreditCardBlocks: CreditCardBlocksType = {\r\n  [CreditCardType.UATP]: [4, 5, 6],\r\n  [CreditCardType.AMEX]: [4, 6, 5],\r\n  [CreditCardType.DINERS]: [4, 6, 4],\r\n  [CreditCardType.DISCOVER]: [4, 4, 4, 4],\r\n  [CreditCardType.MASTERCARD]: [4, 4, 4, 4],\r\n  [CreditCardType.DANKORT]: [4, 4, 4, 4],\r\n  [CreditCardType.INSTAPAYMENT]: [4, 4, 4, 4],\r\n  [CreditCardType.JCB15]: [4, 6, 5],\r\n  [CreditCardType.JCB]: [4, 4, 4, 4],\r\n  [CreditCardType.MAESTRO]: [4, 4, 4, 4],\r\n  [CreditCardType.VISA]: [4, 4, 4, 4],\r\n  [CreditCardType.MIR]: [4, 4, 4, 4],\r\n  [CreditCardType.UNIONPAY]: [4, 4, 4, 4],\r\n  [CreditCardType.GENERAL]: [4, 4, 4, 4],\r\n}\r\n\r\nexport const CreditCardRegex: CreditCardRegexType = {\r\n  // starts with 1; 15 digits, not starts with 1800 (jcb card)\r\n  [CreditCardType.UATP]: /^(?!1800)1\\d{0,14}/,\r\n\r\n  // starts with 34/37; 15 digits\r\n  [CreditCardType.AMEX]: /^3[47]\\d{0,13}/,\r\n\r\n  // starts with 6011/65/644-649; 16 digits\r\n  [CreditCardType.DISCOVER]: /^(?:6011|65\\d{0,2}|64[4-9]\\d?)\\d{0,12}/,\r\n\r\n  // starts with 300-305/309 or 36/38/39; 14 digits\r\n  [CreditCardType.DINERS]: /^3(?:0([0-5]|9)|[689]\\d?)\\d{0,11}/,\r\n\r\n  // starts with 51-55/2221â€“2720; 16 digits\r\n  [CreditCardType.MASTERCARD]:\r\n    /^(5[1-5]\\d{0,2}|22[2-9]\\d{0,1}|2[3-7]\\d{0,2})\\d{0,12}/,\r\n\r\n  // starts with 5019/4175/4571; 16 digits\r\n  [CreditCardType.DANKORT]: /^(5019|4175|4571)\\d{0,12}/,\r\n\r\n  // starts with 637-639; 16 digits\r\n  [CreditCardType.INSTAPAYMENT]: /^63[7-9]\\d{0,13}/,\r\n\r\n  // starts with 2131/1800; 15 digits\r\n  [CreditCardType.JCB15]: /^(?:2131|1800)\\d{0,11}/,\r\n\r\n  // starts with 2131/1800/35; 16 digits\r\n  [CreditCardType.JCB]: /^(?:35\\d{0,2})\\d{0,12}/,\r\n\r\n  // starts with 50/56-58/6304/67; 16 digits\r\n  [CreditCardType.MAESTRO]: /^(?:5[0678]\\d{0,2}|6304|67\\d{0,2})\\d{0,12}/,\r\n\r\n  // starts with 22; 16 digits\r\n  [CreditCardType.MIR]: /^220[0-4]\\d{0,12}/,\r\n\r\n  // starts with 4; 16 digits\r\n  [CreditCardType.VISA]: /^4\\d{0,15}/,\r\n\r\n  // starts with 62/81; 16 digits\r\n  [CreditCardType.UNIONPAY]: /^(62|81)\\d{0,14}/,\r\n}\r\n","import type { DelimiterType } from '../common/types'\r\n\r\nexport enum NumeralThousandGroupStyles {\r\n  THOUSAND = 'thousand',\r\n  LAKH = 'lakh',\r\n  WAN = 'wan',\r\n  NONE = 'none',\r\n}\r\nexport const DefaultNumeralDelimiter: DelimiterType = ','\r\nexport const DefaultNumeralDecimalMark: DelimiterType = '.'\r\nexport const DefaultNumeralThousandGroupStyle: NumeralThousandGroupStyles =\r\n  NumeralThousandGroupStyles.THOUSAND\r\nexport const DefaultNumeralDecimalScale: number = 2\r\nexport const DefaultNumeralIntegerScale: number = 0 // no limit\r\n","import type { BlocksType, DelimiterType } from '../common/types'\r\nimport {\r\n  getFormattedValue,\r\n  getMaxLength,\r\n  headStr,\r\n  stripDelimiters,\r\n  stripNonNumeric,\r\n} from '../common/utils'\r\nimport {\r\n  CreditCardBlocks,\r\n  CreditCardRegex,\r\n  CreditCardType,\r\n  DefaultCreditCardDelimiter,\r\n} from './constants'\r\nimport type {\r\n  CreditCardInfoProps,\r\n  FormatCreditCardOptions,\r\n  GetCreditCardInfoProps,\r\n  CreditCardExcludeGeneralType,\r\n} from './types'\r\n\r\nconst getStrictBlocks = (blocks: BlocksType): BlocksType => {\r\n  const total: number = blocks.reduce(\r\n    (prev: number, current: number) => prev + current,\r\n    0\r\n  )\r\n\r\n  return blocks.concat(19 - total)\r\n}\r\n\r\nconst getCreditCardInfo = ({\r\n  value,\r\n  strictMode,\r\n}: GetCreditCardInfoProps): CreditCardInfoProps => {\r\n  // Some credit card can have up to 19 digits number.\r\n  // Set strictMode to true will remove the 16 max-length restrain,\r\n  // however, I never found any website validate card number like\r\n  // this, hence probably you don't want to enable this option.\r\n  for (const key of Object.keys(CreditCardRegex) as Array<\r\n    CreditCardExcludeGeneralType<CreditCardType>\r\n  >) {\r\n    if (CreditCardRegex[key].test(value)) {\r\n      const matchedBlocks: BlocksType = CreditCardBlocks[key]\r\n      return {\r\n        type: key,\r\n        blocks:\r\n          strictMode ?? false ? getStrictBlocks(matchedBlocks) : matchedBlocks,\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    type: CreditCardType.GENERAL,\r\n    blocks:\r\n      strictMode ?? false\r\n        ? getStrictBlocks(CreditCardBlocks.general)\r\n        : CreditCardBlocks.general,\r\n  }\r\n}\r\n\r\nexport const formatCreditCard = (\r\n  value: string,\r\n  options?: FormatCreditCardOptions\r\n): string => {\r\n  const {\r\n    delimiter = DefaultCreditCardDelimiter,\r\n    delimiterLazyShow = false,\r\n    strictMode = false,\r\n  } = options ?? {}\r\n\r\n  // strip non-numeric characters\r\n  value = stripNonNumeric(value)\r\n\r\n  // strip delimiters\r\n  value = stripDelimiters({\r\n    value,\r\n    delimiters: [delimiter],\r\n  })\r\n\r\n  const { blocks }: CreditCardInfoProps = getCreditCardInfo({\r\n    value,\r\n    strictMode,\r\n  })\r\n\r\n  // max length\r\n  const maxLength = getMaxLength(blocks)\r\n  value = headStr(value, maxLength)\r\n\r\n  // calculate\r\n  value = getFormattedValue({\r\n    value,\r\n    blocks,\r\n    delimiter,\r\n    delimiterLazyShow,\r\n  })\r\n\r\n  return value\r\n}\r\n\r\nexport const getCreditCardType = (\r\n  value: string,\r\n  delimiter?: DelimiterType\r\n): CreditCardType => {\r\n  // strip non-numeric characters\r\n  value = stripNonNumeric(value)\r\n  // strip delimiters\r\n  value = stripDelimiters({\r\n    value,\r\n    delimiters: [delimiter ?? DefaultCreditCardDelimiter],\r\n  })\r\n\r\n  const { type }: CreditCardInfoProps = getCreditCardInfo({ value })\r\n  return type\r\n}\r\n\r\nexport const unformatCreditCard = (value: string): string =>\r\n  stripNonNumeric(value)\r\n","import type { DelimiterType } from '../common/types'\r\nimport type { DateUnit } from './types'\r\n\r\nexport const DefaultDateDelimiter: DelimiterType = '/'\r\nexport const DefaultDatePattern: DateUnit[] = ['d', 'm', 'Y']\r\n","import type { BlocksType } from '../common/types'\r\nimport {\r\n  stripNonNumeric,\r\n  stripDelimiters,\r\n  getFormattedValue,\r\n  getMaxLength,\r\n  headStr,\r\n} from '../common/utils'\r\nimport { DefaultDateDelimiter, DefaultDatePattern } from './constants'\r\nimport type {\r\n  DateUnit,\r\n  InitDateRangeResults,\r\n  DatePatternType,\r\n  FormatDateOptions,\r\n  DateCalculateOptions,\r\n} from './types'\r\n\r\nconst getBlocksByDatePattern = (datePattern: DatePatternType): BlocksType => {\r\n  const blocks: BlocksType = []\r\n  datePattern.forEach((value: DateUnit) => {\r\n    if (value === 'Y') {\r\n      blocks.push(4)\r\n    } else {\r\n      blocks.push(2)\r\n    }\r\n  })\r\n  return blocks\r\n}\r\n\r\nconst getDateRange = ({\r\n  dateMin,\r\n  dateMax,\r\n}: {\r\n  dateMin: string\r\n  dateMax: string\r\n}): InitDateRangeResults => {\r\n  const min: number[] = dateMin\r\n    .split('-')\r\n    .reverse()\r\n    .map((x: string) => parseInt(x, 10))\r\n  if (min.length === 2) min.unshift(0)\r\n\r\n  const max: number[] = dateMax\r\n    .split('-')\r\n    .reverse()\r\n    .map((x: string) => parseInt(x, 10))\r\n  if (max.length === 2) max.unshift(0)\r\n\r\n  return { min, max }\r\n}\r\n\r\nconst addLeadingZeroForYear = (\r\n  number: number,\r\n  fullYearMode: boolean\r\n): string => {\r\n  if (fullYearMode) {\r\n    return (\r\n      (number < 10 ? '000' : number < 100 ? '00' : number < 1000 ? '0' : '') +\r\n      number\r\n    )\r\n  }\r\n\r\n  return (number < 10 ? '0' : '') + number\r\n}\r\n\r\nconst addLeadingZero = (number: number): string =>\r\n  (number < 10 ? '0' : '') + number\r\n\r\nconst getValidatedDate = ({\r\n  value = '',\r\n  blocks = [],\r\n  datePattern,\r\n  min,\r\n  max,\r\n}: DateCalculateOptions): string => {\r\n  let result = ''\r\n\r\n  blocks.forEach((length: number, index: number) => {\r\n    if (value.length > 0) {\r\n      let sub = value.slice(0, length)\r\n      const sub0 = sub.slice(0, 1)\r\n      const rest = value.slice(length)\r\n\r\n      switch (datePattern[index]) {\r\n        case 'd':\r\n          if (sub === '00') {\r\n            sub = '01'\r\n          } else if (parseInt(sub0, 10) > 3) {\r\n            sub = '0' + sub0\r\n          } else if (parseInt(sub, 10) > 31) {\r\n            sub = '31'\r\n          }\r\n\r\n          break\r\n\r\n        case 'm':\r\n          if (sub === '00') {\r\n            sub = '01'\r\n          } else if (parseInt(sub0, 10) > 1) {\r\n            sub = '0' + sub0\r\n          } else if (parseInt(sub, 10) > 12) {\r\n            sub = '12'\r\n          }\r\n\r\n          break\r\n      }\r\n\r\n      result += sub\r\n\r\n      // update remaining string\r\n      value = rest\r\n    }\r\n  })\r\n\r\n  return getFixedDateString({ value: result, datePattern, min, max })\r\n}\r\n\r\nconst getFixedDateString = ({\r\n  value = '',\r\n  datePattern,\r\n  min,\r\n  max,\r\n}: DateCalculateOptions): string => {\r\n  let date: number[] = []\r\n  let dayIndex = 0\r\n  let monthIndex = 0\r\n  let yearIndex = 0\r\n  let dayStartIndex = 0\r\n  let monthStartIndex = 0\r\n  let yearStartIndex = 0\r\n  let day\r\n  let month\r\n  let year\r\n  let fullYearDone = false\r\n\r\n  // mm-dd || dd-mm\r\n  if (\r\n    value.length === 4 &&\r\n    datePattern[0].toLowerCase() !== 'y' &&\r\n    datePattern[1].toLowerCase() !== 'y'\r\n  ) {\r\n    dayStartIndex = datePattern[0] === 'd' ? 0 : 2\r\n    monthStartIndex = 2 - dayStartIndex\r\n    day = parseInt(value.slice(dayStartIndex, dayStartIndex + 2), 10)\r\n    month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10)\r\n\r\n    date = getFixedDate(day, month, 0)\r\n  }\r\n\r\n  // yyyy-mm-dd || yyyy-dd-mm || mm-dd-yyyy || dd-mm-yyyy || dd-yyyy-mm || mm-yyyy-dd\r\n  if (value.length === 8) {\r\n    datePattern.forEach((type: DateUnit, index: number) => {\r\n      switch (type) {\r\n        case 'd':\r\n          dayIndex = index\r\n          break\r\n        case 'm':\r\n          monthIndex = index\r\n          break\r\n        default:\r\n          yearIndex = index\r\n          break\r\n      }\r\n    })\r\n\r\n    yearStartIndex = yearIndex * 2\r\n    dayStartIndex = dayIndex <= yearIndex ? dayIndex * 2 : dayIndex * 2 + 2\r\n    monthStartIndex =\r\n      monthIndex <= yearIndex ? monthIndex * 2 : monthIndex * 2 + 2\r\n\r\n    day = parseInt(value.slice(dayStartIndex, dayStartIndex + 2), 10)\r\n    month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10)\r\n    year = parseInt(value.slice(yearStartIndex, yearStartIndex + 4), 10)\r\n\r\n    fullYearDone = value.slice(yearStartIndex, yearStartIndex + 4).length === 4\r\n\r\n    date = getFixedDate(day, month, year)\r\n  }\r\n\r\n  // mm-yy || yy-mm\r\n  if (\r\n    value.length === 4 &&\r\n    (datePattern[0] === 'y' || datePattern[1] === 'y')\r\n  ) {\r\n    monthStartIndex = datePattern[0] === 'm' ? 0 : 2\r\n    yearStartIndex = 2 - monthStartIndex\r\n    month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10)\r\n    year = parseInt(value.slice(yearStartIndex, yearStartIndex + 2), 10)\r\n\r\n    fullYearDone = value.slice(yearStartIndex, yearStartIndex + 2).length === 2\r\n\r\n    date = [0, month, year]\r\n  }\r\n\r\n  // mm-yyyy || yyyy-mm\r\n  if (\r\n    value.length === 6 &&\r\n    (datePattern[0] === 'Y' || datePattern[1] === 'Y')\r\n  ) {\r\n    monthStartIndex = datePattern[0] === 'm' ? 0 : 4\r\n    yearStartIndex = 2 - 0.5 * monthStartIndex\r\n    month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10)\r\n    year = parseInt(value.slice(yearStartIndex, yearStartIndex + 4), 10)\r\n\r\n    fullYearDone = value.slice(yearStartIndex, yearStartIndex + 4).length === 4\r\n\r\n    date = [0, month, year]\r\n  }\r\n\r\n  date = getRangeFixedDate({ date, datePattern, min, max })\r\n\r\n  const result: string =\r\n    date.length === 0\r\n      ? value\r\n      : datePattern.reduce((previous: string, current: DateUnit) => {\r\n          switch (current) {\r\n            case 'd':\r\n              return previous + (date[0] === 0 ? '' : addLeadingZero(date[0]))\r\n            case 'm':\r\n              return previous + (date[1] === 0 ? '' : addLeadingZero(date[1]))\r\n            case 'y':\r\n              return (\r\n                previous +\r\n                (fullYearDone ? addLeadingZeroForYear(date[2], false) : '')\r\n              )\r\n            case 'Y':\r\n              return (\r\n                previous +\r\n                (fullYearDone ? addLeadingZeroForYear(date[2], true) : '')\r\n              )\r\n          }\r\n          return previous\r\n        }, '')\r\n\r\n  return result\r\n}\r\n\r\nconst isLeapYear = (year: number): boolean =>\r\n  (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0\r\n\r\nconst getFixedDate = (day: number, month: number, year: number): number[] => {\r\n  day = Math.min(day, 31)\r\n  month = Math.min(month, 12)\r\n  year = year ?? 0\r\n\r\n  if ((month < 7 && month % 2 === 0) || (month > 8 && month % 2 === 1)) {\r\n    day = Math.min(day, month === 2 ? (isLeapYear(year) ? 29 : 28) : 30)\r\n  }\r\n\r\n  return [day, month, year]\r\n}\r\n\r\nconst getRangeFixedDate = ({\r\n  date = [],\r\n  min,\r\n  max,\r\n  datePattern,\r\n}: DateCalculateOptions): number[] => {\r\n  if (date.length === 0 || (min.length < 3 && max.length < 3)) return date\r\n\r\n  const hasYearInPattern: boolean =\r\n    datePattern.filter((x: DateUnit) => x.toLowerCase() === 'y').length > 0\r\n  if (hasYearInPattern && date[2] === 0) {\r\n    return date\r\n  }\r\n\r\n  if (\r\n    max.length > 0 &&\r\n    (max[2] < date[2] ||\r\n      (max[2] === date[2] &&\r\n        (max[1] < date[1] || (max[1] === date[1] && max[0] < date[0]))))\r\n  ) {\r\n    return max\r\n  }\r\n\r\n  if (\r\n    min.length > 0 &&\r\n    (min[2] > date[2] ||\r\n      (min[2] === date[2] &&\r\n        (min[1] > date[1] || (min[1] === date[1] && min[0] > date[0]))))\r\n  ) {\r\n    return min\r\n  }\r\n\r\n  return date\r\n}\r\n\r\nexport const formatDate = (\r\n  value: string,\r\n  options?: FormatDateOptions\r\n): string => {\r\n  const {\r\n    delimiterLazyShow = false,\r\n    delimiter = DefaultDateDelimiter,\r\n    datePattern = DefaultDatePattern,\r\n    dateMax = '',\r\n    dateMin = '',\r\n  } = options ?? {}\r\n  // strip non-numeric characters\r\n  value = stripNonNumeric(value)\r\n\r\n  const blocks: BlocksType = getBlocksByDatePattern(datePattern)\r\n  const { min, max } = getDateRange({\r\n    dateMax,\r\n    dateMin,\r\n  })\r\n\r\n  value = getValidatedDate({\r\n    value,\r\n    blocks,\r\n    datePattern,\r\n    min,\r\n    max,\r\n  })\r\n\r\n  // strip delimiters\r\n  value = stripDelimiters({\r\n    value,\r\n    delimiters: [delimiter],\r\n  })\r\n\r\n  // max length\r\n  const maxLength = getMaxLength(blocks)\r\n  value = headStr(value, maxLength)\r\n\r\n  // calculate\r\n  value = getFormattedValue({\r\n    value,\r\n    blocks,\r\n    delimiter,\r\n    delimiterLazyShow,\r\n  })\r\n\r\n  return value\r\n}\r\n","import type { DelimiterType } from '../common/types'\r\nimport type { TimeFormatType, TimeUnit } from './types'\r\n\r\nexport const DefaultTimeFormat: TimeFormatType = '24'\r\nexport const DefaultTimeDelimiter: DelimiterType = ':'\r\nexport const DefaultTimePattern: TimeUnit[] = ['h', 'm', 's']\r\n","import type { BlocksType } from '../common/types'\r\nimport {\r\n  stripNonNumeric,\r\n  stripDelimiters,\r\n  getFormattedValue,\r\n  getMaxLength,\r\n  headStr,\r\n} from '../common/utils'\r\nimport {\r\n  DefaultTimeDelimiter,\r\n  DefaultTimeFormat,\r\n  DefaultTimePattern,\r\n} from './constants'\r\nimport type {\r\n  FormatTimeOptions,\r\n  TimeFormatType,\r\n  TimeFormatOptions,\r\n  TimePatternType,\r\n  GetFixedTimeStringProps,\r\n  GetValidatedTimeProps,\r\n  TimeUnit,\r\n} from './types'\r\n\r\nconst getTimeFormatOptions = (\r\n  timeFormat: TimeFormatType\r\n): TimeFormatOptions => {\r\n  if (timeFormat === '12') {\r\n    return {\r\n      maxHourFirstDigit: 1,\r\n      maxHours: 12,\r\n      maxMinutesFirstDigit: 5,\r\n      maxMinutes: 60,\r\n    }\r\n  }\r\n\r\n  return {\r\n    maxHourFirstDigit: 2,\r\n    maxHours: 23,\r\n    maxMinutesFirstDigit: 5,\r\n    maxMinutes: 60,\r\n  }\r\n}\r\n\r\nconst addLeadingZero = (number: number): string =>\r\n  (number < 10 ? '0' : '') + number\r\n\r\nconst getBlocksByTimePattern = (timePattern: TimePatternType): BlocksType => {\r\n  const blocks: BlocksType = []\r\n  timePattern.forEach(() => {\r\n    blocks.push(2)\r\n  })\r\n  return blocks\r\n}\r\n\r\nconst getFixedTime = (\r\n  hour: number,\r\n  minute: number,\r\n  second: number\r\n): number[] => {\r\n  second = Math.min(second, 60)\r\n  minute = Math.min(minute, 60)\r\n  hour = Math.min(hour, 60)\r\n\r\n  return [hour, minute, second]\r\n}\r\n\r\nconst getFixedTimeString = ({\r\n  value,\r\n  timePattern,\r\n}: GetFixedTimeStringProps): string => {\r\n  let time: number[] = []\r\n  let secondIndex = 0\r\n  let minuteIndex = 0\r\n  let hourIndex = 0\r\n  let secondStartIndex = 0\r\n  let minuteStartIndex = 0\r\n  let hourStartIndex = 0\r\n  let second\r\n  let minute\r\n  let hour\r\n\r\n  if (value.length === 6) {\r\n    timePattern.forEach((type, index) => {\r\n      switch (type) {\r\n        case 's':\r\n          secondIndex = index * 2\r\n          break\r\n        case 'm':\r\n          minuteIndex = index * 2\r\n          break\r\n        case 'h':\r\n          hourIndex = index * 2\r\n          break\r\n      }\r\n    })\r\n\r\n    hourStartIndex = hourIndex\r\n    minuteStartIndex = minuteIndex\r\n    secondStartIndex = secondIndex\r\n\r\n    second = parseInt(value.slice(secondStartIndex, secondStartIndex + 2), 10)\r\n    minute = parseInt(value.slice(minuteStartIndex, minuteStartIndex + 2), 10)\r\n    hour = parseInt(value.slice(hourStartIndex, hourStartIndex + 2), 10)\r\n\r\n    time = getFixedTime(hour, minute, second)\r\n  }\r\n\r\n  if (value.length === 4 && !timePattern.includes('s')) {\r\n    timePattern.forEach((type: TimeUnit, index: number) => {\r\n      switch (type) {\r\n        case 'm':\r\n          minuteIndex = index * 2\r\n          break\r\n        case 'h':\r\n          hourIndex = index * 2\r\n          break\r\n      }\r\n    })\r\n\r\n    hourStartIndex = hourIndex\r\n    minuteStartIndex = minuteIndex\r\n\r\n    second = 0\r\n    minute = parseInt(value.slice(minuteStartIndex, minuteStartIndex + 2), 10)\r\n    hour = parseInt(value.slice(hourStartIndex, hourStartIndex + 2), 10)\r\n\r\n    time = getFixedTime(hour, minute, second)\r\n  }\r\n\r\n  return time.length === 0\r\n    ? value\r\n    : timePattern.reduce((previous: string, current: TimeUnit): string => {\r\n        switch (current) {\r\n          case 's':\r\n            return previous + addLeadingZero(time[2])\r\n          case 'm':\r\n            return previous + addLeadingZero(time[1])\r\n          case 'h':\r\n            return previous + addLeadingZero(time[0])\r\n        }\r\n        return previous\r\n      }, '')\r\n}\r\n\r\nconst getValidatedTime = ({\r\n  value,\r\n  blocks,\r\n  timePattern,\r\n  timeFormat,\r\n}: GetValidatedTimeProps): string => {\r\n  let result: string = ''\r\n\r\n  const timeFormatOptions: TimeFormatOptions = getTimeFormatOptions(timeFormat)\r\n\r\n  blocks.forEach((length: number, index: number) => {\r\n    if (value.length > 0) {\r\n      let sub = value.slice(0, length)\r\n      const sub0 = sub.slice(0, 1)\r\n      const rest = value.slice(length)\r\n\r\n      switch (timePattern[index]) {\r\n        case 'h':\r\n          if (parseInt(sub0, 10) > timeFormatOptions.maxHourFirstDigit) {\r\n            sub = '0' + sub0\r\n          } else if (parseInt(sub, 10) > timeFormatOptions.maxHours) {\r\n            sub = timeFormatOptions.maxHours + ''\r\n          }\r\n\r\n          break\r\n        case 'm':\r\n        case 's':\r\n          if (parseInt(sub0, 10) > timeFormatOptions.maxMinutesFirstDigit) {\r\n            sub = '0' + sub0\r\n          } else if (parseInt(sub, 10) > timeFormatOptions.maxMinutes) {\r\n            sub = timeFormatOptions.maxMinutes + ''\r\n          }\r\n          break\r\n      }\r\n\r\n      result += sub\r\n\r\n      // update remaining string\r\n      value = rest\r\n    }\r\n  })\r\n\r\n  return getFixedTimeString({ value: result, timePattern })\r\n}\r\n\r\nexport const formatTime = (\r\n  value: string,\r\n  options?: FormatTimeOptions\r\n): string => {\r\n  const {\r\n    delimiterLazyShow = false,\r\n    delimiter = DefaultTimeDelimiter,\r\n    timePattern = DefaultTimePattern,\r\n    timeFormat = DefaultTimeFormat,\r\n  } = options ?? {}\r\n  // strip non-numeric characters\r\n  value = stripNonNumeric(value)\r\n\r\n  const blocks: BlocksType = getBlocksByTimePattern(timePattern)\r\n  value = getValidatedTime({\r\n    value,\r\n    blocks,\r\n    timePattern,\r\n    timeFormat,\r\n  })\r\n\r\n  // strip delimiters\r\n  value = stripDelimiters({\r\n    value,\r\n    delimiters: [delimiter],\r\n  })\r\n\r\n  // max length\r\n  const maxLength = getMaxLength(blocks)\r\n  value = headStr(value, maxLength)\r\n\r\n  // calculate\r\n  value = getFormattedValue({\r\n    value,\r\n    blocks,\r\n    delimiter,\r\n    delimiterLazyShow,\r\n  })\r\n\r\n  return value\r\n}\r\n","import {\r\n  getFormattedValue,\r\n  stripDelimiters,\r\n  stripNonNumeric,\r\n} from '../common/utils'\r\nimport type { FormatGeneralOptions, GetPrefixStrippedValueProps } from './types'\r\n\r\n// strip prefix\r\nconst stripPrefix = ({\r\n  value,\r\n  prefix,\r\n  tailPrefix,\r\n}: GetPrefixStrippedValueProps): string => {\r\n  const prefixLength: number = prefix.length\r\n\r\n  // No prefix\r\n  if (prefixLength === 0) {\r\n    return value\r\n  }\r\n\r\n  // Value is prefix\r\n  if (value === prefix && value !== '') {\r\n    return ''\r\n  }\r\n\r\n  // result prefix string does not match pre-defined prefix\r\n  if (value.slice(0, prefixLength) !== prefix && !tailPrefix) {\r\n    return ''\r\n  } else if (value.slice(-prefixLength) !== prefix && tailPrefix) {\r\n    return ''\r\n  }\r\n\r\n  // No issue, strip prefix for new value\r\n  return tailPrefix ? value.slice(0, -prefixLength) : value.slice(prefixLength)\r\n}\r\n\r\nexport const formatGeneral = (\r\n  value: string,\r\n  options: FormatGeneralOptions\r\n): string => {\r\n  const {\r\n    blocks,\r\n    delimiter = '',\r\n    delimiters = [],\r\n    delimiterLazyShow = false,\r\n    prefix = '',\r\n    numericOnly = false,\r\n    uppercase = false,\r\n    lowercase = false,\r\n  } = options\r\n\r\n  const tailPrefix: boolean = false // This is too buggy to be true\r\n\r\n  if (delimiter.length > 0) {\r\n    delimiters.push(delimiter)\r\n  }\r\n\r\n  // strip delimiters\r\n  value = stripDelimiters({\r\n    value,\r\n    delimiters,\r\n  })\r\n\r\n  // strip prefix\r\n  value = stripPrefix({\r\n    value,\r\n    prefix,\r\n    tailPrefix,\r\n  })\r\n\r\n  // strip non-numeric characters\r\n  value = numericOnly ? stripNonNumeric(value) : value\r\n\r\n  // convert case\r\n  value = uppercase ? value.toUpperCase() : value\r\n  value = lowercase ? value.toLowerCase() : value\r\n\r\n  // prevent from showing prefix when no immediate option enabled with empty input value\r\n  if (prefix.length > 0) {\r\n    if (tailPrefix) {\r\n      value = value + prefix\r\n    } else {\r\n      value = prefix + value\r\n    }\r\n  }\r\n\r\n  // apply blocks\r\n  value = getFormattedValue({\r\n    value,\r\n    blocks,\r\n    delimiter,\r\n    delimiters,\r\n    delimiterLazyShow,\r\n  })\r\n\r\n  return value\r\n}\r\n\r\nexport const unformatGeneral = (\r\n  value: string,\r\n  options: Pick<FormatGeneralOptions, 'delimiter' | 'delimiters'>\r\n): string => {\r\n  const { delimiter = '', delimiters = [] } = options\r\n  return stripDelimiters({ value, delimiters: [...delimiters, delimiter] })\r\n}\r\n","import type { FormatNumeralRequiredProps, FormatNumeralOptions } from './types'\r\n\r\nimport {\r\n  DefaultNumeralDecimalMark,\r\n  DefaultNumeralDelimiter,\r\n  DefaultNumeralThousandGroupStyle,\r\n  DefaultNumeralDecimalScale,\r\n  DefaultNumeralIntegerScale,\r\n  NumeralThousandGroupStyles,\r\n} from './constants'\r\n\r\nconst format = ({\r\n  value,\r\n  delimiter,\r\n  numeralDecimalMark,\r\n  numeralDecimalScale,\r\n  stripLeadingZeroes,\r\n  numeralPositiveOnly,\r\n  numeralIntegerScale,\r\n  numeralThousandsGroupStyle,\r\n  signBeforePrefix,\r\n  tailPrefix,\r\n  prefix,\r\n}: FormatNumeralRequiredProps): string => {\r\n  let parts: string[]\r\n  let partSignAndPrefix: string\r\n  let partInteger: string\r\n  let partDecimal: string = ''\r\n\r\n  // strip alphabet letters\r\n  let result: string = value\r\n    .replace(/[A-Za-z]/g, '')\r\n\r\n    // replace the first decimal mark with reserved placeholder\r\n    .replace(numeralDecimalMark, 'M')\r\n\r\n    // strip non numeric letters except minus and \"M\"\r\n    // this is to ensure prefix has been stripped\r\n    .replace(/[^\\dM-]/g, '')\r\n\r\n    // replace the leading minus with reserved placeholder\r\n    .replace(/^-/, 'N')\r\n\r\n    // strip the other minus sign (if present)\r\n    .replace(/-/g, '')\r\n\r\n    // replace the minus sign (if present)\r\n    .replace('N', numeralPositiveOnly ?? false ? '' : '-')\r\n\r\n    // replace decimal mark\r\n    .replace('M', numeralDecimalMark)\r\n\r\n  // strip any leading zeros\r\n  if (stripLeadingZeroes) {\r\n    result = result.replace(/^(-)?0+(?=\\d)/, '$1')\r\n  }\r\n\r\n  const partSign: string = result.slice(0, 1) === '-' ? '-' : ''\r\n\r\n  if (signBeforePrefix) {\r\n    partSignAndPrefix = partSign + prefix\r\n  } else {\r\n    partSignAndPrefix = prefix + partSign\r\n  }\r\n\r\n  partInteger = result\r\n\r\n  if (result.includes(numeralDecimalMark)) {\r\n    parts = result.split(numeralDecimalMark)\r\n    partInteger = parts[0]\r\n    partDecimal = numeralDecimalMark + parts[1].slice(0, numeralDecimalScale)\r\n  }\r\n\r\n  if (partSign === '-') {\r\n    partInteger = partInteger.slice(1)\r\n  }\r\n\r\n  if (numeralIntegerScale > 0) {\r\n    partInteger = partInteger.slice(0, numeralIntegerScale)\r\n  }\r\n\r\n  switch (numeralThousandsGroupStyle) {\r\n    case NumeralThousandGroupStyles.LAKH:\r\n      partInteger = partInteger.replace(/(\\d)(?=(\\d\\d)+\\d$)/g, '$1' + delimiter)\r\n      break\r\n\r\n    case NumeralThousandGroupStyles.WAN:\r\n      partInteger = partInteger.replace(/(\\d)(?=(\\d{4})+$)/g, '$1' + delimiter)\r\n      break\r\n\r\n    case NumeralThousandGroupStyles.THOUSAND:\r\n      partInteger = partInteger.replace(/(\\d)(?=(\\d{3})+$)/g, '$1' + delimiter)\r\n      break\r\n  }\r\n\r\n  if (tailPrefix) {\r\n    return (\r\n      partSign +\r\n      partInteger +\r\n      (numeralDecimalScale > 0 ? partDecimal : '') +\r\n      prefix\r\n    )\r\n  }\r\n\r\n  return (\r\n    partSignAndPrefix +\r\n    partInteger +\r\n    (numeralDecimalScale > 0 ? partDecimal : '')\r\n  )\r\n}\r\n\r\nexport const formatNumeral = (\r\n  value: string,\r\n  options?: FormatNumeralOptions\r\n): string => {\r\n  const {\r\n    delimiter = DefaultNumeralDelimiter,\r\n    numeralThousandsGroupStyle = DefaultNumeralThousandGroupStyle,\r\n    numeralIntegerScale = DefaultNumeralIntegerScale,\r\n    numeralDecimalMark = DefaultNumeralDecimalMark,\r\n    numeralDecimalScale = DefaultNumeralDecimalScale,\r\n    stripLeadingZeroes = true,\r\n    numeralPositiveOnly = false,\r\n    tailPrefix = false,\r\n    signBeforePrefix = false,\r\n    prefix = '',\r\n  } = options ?? {}\r\n\r\n  value = format({\r\n    value,\r\n    delimiter,\r\n    numeralIntegerScale,\r\n    numeralDecimalMark,\r\n    numeralDecimalScale,\r\n    stripLeadingZeroes,\r\n    numeralPositiveOnly,\r\n    numeralThousandsGroupStyle,\r\n    tailPrefix,\r\n    signBeforePrefix,\r\n    prefix,\r\n  })\r\n\r\n  return value\r\n}\r\n\r\nexport const unformatNumeral = (\r\n  value: string,\r\n  options?: Pick<FormatNumeralOptions, 'numeralDecimalMark'>\r\n): string => {\r\n  const { numeralDecimalMark = DefaultNumeralDecimalMark } = options ?? {}\r\n\r\n  return value\r\n    .replace(numeralDecimalMark, 'M')\r\n    .replace(/[^0-9-M]/g, '')\r\n    .replace('M', '.')\r\n}\r\n","import type { DelimiterType } from '../common/types'\r\nimport { stripDelimiters } from '../common/utils'\r\nimport type {\r\n  CalculeteCleanCursorIndexProps,\r\n  CalculeteDirtyCursorIndexProps,\r\n  RegisterCursorTrackerPropsType,\r\n  CursorTrackerInputElement,\r\n  CursorTrackerDestructor,\r\n} from './types'\r\n\r\nconst calculeteCleanCursorIndex = ({\r\n  value,\r\n  dirtyCursorIndex,\r\n  delimiters,\r\n}: CalculeteCleanCursorIndexProps): number => {\r\n  let index: number = dirtyCursorIndex\r\n  for (let charIndex = 0; charIndex < dirtyCursorIndex; charIndex++) {\r\n    if (delimiters.includes(value[charIndex])) {\r\n      index--\r\n    }\r\n  }\r\n  return index\r\n}\r\n\r\nconst calculeteDirtyCursorIndex = ({\r\n  value,\r\n  cleanCursorIndex,\r\n  delimiters,\r\n}: CalculeteDirtyCursorIndexProps): number => {\r\n  let index: number = cleanCursorIndex\r\n  for (let charIndex = 0; charIndex < value.length; charIndex++) {\r\n    if (delimiters.includes(value[charIndex])) {\r\n      index++\r\n    }\r\n    if (charIndex === index - 1) {\r\n      break\r\n    }\r\n  }\r\n\r\n  return index\r\n}\r\n\r\nexport const registerCursorTracker = ({\r\n  input,\r\n  delimiter = '',\r\n  delimiters = [],\r\n  prefix = '',\r\n}: RegisterCursorTrackerPropsType): CursorTrackerDestructor => {\r\n  const cursorTrackerInput: CursorTrackerInputElement =\r\n    input as CursorTrackerInputElement\r\n\r\n  if (cursorTrackerInput.CLEAVE_ZEN_cursor_tracker !== undefined) {\r\n    return () => {\r\n      cursorTrackerInput.removeEventListener(\r\n        'input',\r\n        cursorTrackerInput.CLEAVE_ZEN_cursor_tracker\r\n      )\r\n      cursorTrackerInput.CLEAVE_ZEN_cursor_tracker = undefined\r\n    }\r\n  }\r\n\r\n  const cursorTrackerDelimiters: DelimiterType[] = [delimiter, ...delimiters]\r\n\r\n  cursorTrackerInput.CLEAVE_ZEN_cursor_tracker = (e: InputEvent) => {\r\n    const isBackward = e.inputType === 'deleteContentBackward'\r\n\r\n    const element: CursorTrackerInputElement =\r\n      e.target as CursorTrackerInputElement\r\n\r\n    // if typing from the end but not backward, do nothing\r\n    if (!isBackward && element.value.length === element.selectionEnd) {\r\n      return\r\n    }\r\n    element.CLEAVE_ZEN_cleanCursorIndex = calculeteCleanCursorIndex({\r\n      value: element.value,\r\n      dirtyCursorIndex: element.selectionEnd ?? 0,\r\n      delimiters: cursorTrackerDelimiters,\r\n    })\r\n    setTimeout(() => {\r\n      // if current value is only to add the delimiter after prefix, do nothing\r\n      if (\r\n        stripDelimiters({\r\n          value: element.value,\r\n          delimiters: cursorTrackerDelimiters,\r\n        }) === prefix\r\n      ) {\r\n        return\r\n      }\r\n      const dirtyCursorIndex = calculeteDirtyCursorIndex({\r\n        value: element.value,\r\n        cleanCursorIndex: element.CLEAVE_ZEN_cleanCursorIndex ?? 0,\r\n        delimiters: cursorTrackerDelimiters,\r\n      })\r\n      element.setSelectionRange(dirtyCursorIndex, dirtyCursorIndex)\r\n    }, 0)\r\n  }\r\n\r\n  cursorTrackerInput.addEventListener(\r\n    'input',\r\n    cursorTrackerInput.CLEAVE_ZEN_cursor_tracker\r\n  )\r\n\r\n  return () => {\r\n    cursorTrackerInput.removeEventListener(\r\n      'input',\r\n      cursorTrackerInput.CLEAVE_ZEN_cursor_tracker\r\n    )\r\n    cursorTrackerInput.CLEAVE_ZEN_cursor_tracker = undefined\r\n  }\r\n}\r\n"],"names":["CreditCardType","stripNonNumeric","value","replace","getMaxLength","blocks","reduce","previous","current","headStr","str","length","slice","stripDelimiters","_ref","delimiters","forEach","split","letter","RegExp","getFormattedValue","_ref2","_ref2$delimiter","delimiter","_ref2$delimiters","_ref2$delimiterLazySh","delimiterLazyShow","result","valueRemaining","currentDelimiter","index","_delimiters","sub","rest","NumeralThousandGroupStyles","CreditCardBlocks","_CreditCardBlocks","UATP","AMEX","DINERS","DISCOVER","MASTERCARD","DANKORT","INSTAPAYMENT","JCB15","JCB","MAESTRO","VISA","MIR","UNIONPAY","GENERAL","CreditCardRegex","_CreditCardRegex","getStrictBlocks","total","prev","concat","getCreditCardInfo","strictMode","_i","_Object$keys","Object","keys","key","test","matchedBlocks","type","general","DefaultNumeralThousandGroupStyle","THOUSAND","DefaultDatePattern","addLeadingZeroForYear","number","fullYearMode","addLeadingZero","getFixedDate","day","month","year","_year","Math","min","isLeapYear","DefaultTimePattern","getFixedTime","hour","minute","second","options","_ref2$strictMode","maxLength","_ref5","_ref5$delimiterLazySh","_ref5$delimiter","DefaultDateDelimiter","_ref5$datePattern","datePattern","_ref5$dateMax","dateMax","_ref5$dateMin","dateMin","push","getBlocksByDatePattern","_getDateRange","reverse","map","x","parseInt","unshift","max","getDateRange","_ref2$value","_ref2$blocks","sub0","_ref3","_ref3$value","date","dayIndex","monthIndex","yearIndex","dayStartIndex","monthStartIndex","yearStartIndex","fullYearDone","toLowerCase","_ref4","_ref4$date","filter","getRangeFixedDate","getFixedDateString","getValidatedDate","_options$delimiter","_options$delimiters","_options$delimiterLaz","_options$prefix","prefix","_options$numericOnly","numericOnly","_options$uppercase","uppercase","_options$lowercase","lowercase","tailPrefix","prefixLength","stripPrefix","toUpperCase","_ref2$numeralThousand","numeralThousandsGroupStyle","_ref2$numeralIntegerS","numeralIntegerScale","_ref2$numeralDecimalM","numeralDecimalMark","_ref2$numeralDecimalS","numeralDecimalScale","_ref2$stripLeadingZer","stripLeadingZeroes","_ref2$numeralPositive","numeralPositiveOnly","_ref2$tailPrefix","_ref2$signBeforePrefi","signBeforePrefix","_ref2$prefix","parts","partSignAndPrefix","partInteger","partDecimal","partSign","includes","LAKH","WAN","format","DefaultNumeralDelimiter","DefaultNumeralDecimalScale","_ref3$delimiterLazySh","_ref3$delimiter","DefaultTimeDelimiter","_ref3$timePattern","timePattern","_ref3$timeFormat","timeFormat","getBlocksByTimePattern","timeFormatOptions","maxHourFirstDigit","maxHours","maxMinutesFirstDigit","maxMinutes","time","secondIndex","minuteIndex","hourIndex","secondStartIndex","minuteStartIndex","hourStartIndex","getFixedTimeString","getValidatedTime","_ref3$delimiters","_ref3$prefix","cursorTrackerInput","input","undefined","CLEAVE_ZEN_cursor_tracker","removeEventListener","cursorTrackerDelimiters","e","_element$selectionEnd","element","target","inputType","selectionEnd","CLEAVE_ZEN_cleanCursorIndex","dirtyCursorIndex","charIndex","calculeteCleanCursorIndex","setTimeout","_element$CLEAVE_ZEN_c","cleanCursorIndex","calculeteDirtyCursorIndex","setSelectionRange","addEventListener","_options$delimiter2","_options$delimiters2","_ref3$numeralDecimalM"],"mappings":"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"}